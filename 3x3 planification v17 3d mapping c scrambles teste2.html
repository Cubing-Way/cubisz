<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Create 3x3 Grids of Smaller Squares</title>
<style>
    .grid-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 600px;
      transform: scale(0.5); /* Adjust scale factor as needed */
      transform-origin: center; /* Ensure scaling happens from center */
    }

  .grid {
    display: grid;
    grid-template-columns: repeat(3, 60px); /* 3 columns of 60px each */
    gap: 5px; /* gap between the squares */
    border: 2px solid black; /* Add a black border */
    padding: 5px; /* Optional padding inside the border */
  }

  .square {
    width: 60px; /* width of each square */
    height: 60px; /* height of each square */
  }

  .white-square {
    background-color: white;
  }

  .orange-square {
    background-color: orange;
  }

  .green-square {
    background-color: green;
  }

  .red-square {
    background-color: red;
  }

  .blue-square {
    background-color: blue;
  }

  .yellow-square {
    background-color: yellow;
  }
 
 #scramble {
  font-size: 24px;
 }
</style>
</head>
<body>
  
<div id="scramble"></div>    

<div class="grid-container">
  <!-- White 3x3 grid -->
  <div id="whiteSquareGrid" class="grid"style="position: relative; bottom: 200px; left: 408px;">
  </div>

  <!-- Orange 3x3 grid -->
  <div id="orangeSquareGrid" class="grid">
  </div>

  <!-- Green 3x3 grid -->
  <div id="greenSquareGrid" class="grid">
  </div>

  <!-- Red 3x3 grid -->
  <div id="redSquareGrid" class="grid">
  </div>

  <!-- Blue 3x3 grid -->
  <div id="blueSquareGrid" class="grid">
  </div>

  <!-- Yellow 3x3 grid -->
  <div id="yellowSquareGrid" class="grid"style="position: relative; top: 200px; right: 612px;">
  </div>
</div>


  


<script>
  


  // Function to create grid squares
  function createGrid(containerId, squareClass) {
    let squaregrid = document.getElementById(containerId);
    for (let i = 0; i < 9; i++) {
      let square = document.createElement('div');
      square.className = 'square ' + squareClass;
      squaregrid.appendChild(square);
    }
  }

// Create 3x3 grids for different colors
createGrid('whiteSquareGrid', 'white-square');
createGrid('orangeSquareGrid', 'orange-square');
createGrid('greenSquareGrid', 'green-square');
createGrid('redSquareGrid', 'red-square');
createGrid('blueSquareGrid', 'blue-square');
createGrid('yellowSquareGrid', 'yellow-square');

  

  let blueSquares = document.querySelectorAll('#blueSquareGrid .blue-square');
  let redSquares = document.querySelectorAll('#redSquareGrid .red-square');
  let yellowSquares = document.querySelectorAll('#yellowSquareGrid .yellow-square');
  let greenSquares = document.querySelectorAll('#greenSquareGrid .green-square');
  let whiteSquares = document.querySelectorAll('#whiteSquareGrid .white-square');  
  let orangeSquares = document.querySelectorAll('#orangeSquareGrid .orange-square'); 
  
function printScrambleMoves() {

    // Get the current content of the div with ID 'myDivId'
    const displayedScramble = document.getElementById('scramble').textContent;

    // Split the scramble string by spaces to get individual moves
    const moves = displayedScramble.split(' ');

    // Map move notations to their respective functions
    const moveFunctions = {
        "U": U,
        "U'": () => { U(); U(); U(); },
        "U2": () => { U(); U(); },
        "D": D,
        "D'": () => { D(); D(); D(); },
        "D2": () => { D(); D(); },
        "R": R,
        "R'": () => { R(); R(); R(); },
        "R2": () => { R(); R(); },
        "L": L,
        "L'": () => { L(); L(); L(); },
        "L2": () => { L(); L(); },
        "F": F,
        "F'": () => { F(); F(); F(); },
        "F2": () => { F(); F(); },
        "B": B,
        "B'": () => { B(); B(); B(); },
        "B2": () => { B(); B(); }
    };
  
    //Reset to original values
    resetCube();

    // Loop through each move and execute the corresponding function
    moves.forEach(move => {
        // Get the function corresponding to the move notation
        const func = moveFunctions[move];
        
        // Call the function if it exists
        if (func) {
            func();
        } 

        
    });
          
        //Update the colors display     
        paintCubeFromStickers();
}

let scramble = '';

function generateWcaScramble() {
  // list of possible moves
  const moves1 = ['U', 'D'];
  const moves2 = ['L', 'R'];
  const moves3 = ['F'];

  // create a new array that combines the values from all three constants
  const moves = moves1.concat(moves2, moves3);

  // list of possible move modifiers
  const modifiers = ['', "'", '2'];

  // Reset the global scramble variable
  scramble = '';

  let lastMove = null;
  let lastMoveGroup = null;
  let secondLastMoveGroup = null;

  // Declare secondLastMove before using it
  let secondLastMove = null;

  for (let i = 0; i < 20 + Math.floor(Math.random() * 3); i++) {
    let move;
    let moveGroup;
    do {
      move = moves[Math.floor(Math.random() * moves.length)];
      if (moves1.includes(move)) {
        moveGroup = 1;
      } else if (moves2.includes(move)) {
        moveGroup = 2;
      } else if (moves3.includes(move)) {
        moveGroup = 3;
      }
    } while (move === lastMove || (moveGroup === lastMoveGroup && moveGroup === secondLastMoveGroup));
    
    const modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
    scramble += `${move}${modifier} `;
    
    secondLastMove = lastMove;
    lastMove = move;
    secondLastMoveGroup = lastMoveGroup;
    lastMoveGroup = moveGroup;
  }

 

  

}

const cube = {
  U: Array(9).fill('W'),
  R: Array(9).fill('R'),
  F: Array(9).fill('G'),
  D: Array(9).fill('Y'),
  L: Array(9).fill('O'),
  B: Array(9).fill('B')
};

const facesToSquares = {
  U: whiteSquares,
  R: redSquares,
  F: greenSquares,
  D: yellowSquares,
  L: orangeSquares,
  B: blueSquares
};

function paintCubeFromStickers() {
  const colorMap = {
    W: 'white',
    R: 'red',
    G: 'green',
    Y: 'yellow',
    O: 'orange',
    B: 'blue'
  };

  for (const face in cube) {
    const squares = facesToSquares[face];

    for (let i = 0; i < 9; i++) {
      const color = colorMap[cube[face][i]];

      // FULL RESET — no stacking classes
      squares[i].className = `square ${color}-square`;
    }
  }
}


function rotateFaceCW(face) {
  [face[0], face[1], face[2],
   face[3], face[4], face[5],
   face[6], face[7], face[8]] =
  [face[6], face[3], face[0],
   face[7], face[4], face[1],
   face[8], face[5], face[2]];
}

function U() {
  rotateFaceCW(cube.U);

  const f0 = cube.F[0], f1 = cube.F[1], f2 = cube.F[2];
  const r0 = cube.R[0], r1 = cube.R[1], r2 = cube.R[2];
  const b0 = cube.B[0], b1 = cube.B[1], b2 = cube.B[2];
  const l0 = cube.L[0], l1 = cube.L[1], l2 = cube.L[2];

  cube.F[0] = r0; cube.F[1] = r1; cube.F[2] = r2;
  cube.R[0] = b0; cube.R[1] = b1; cube.R[2] = b2;
  cube.B[0] = l0; cube.B[1] = l1; cube.B[2] = l2;
  cube.L[0] = f0; cube.L[1] = f1; cube.L[2] = f2;
}

function D() {
  rotateFaceCW(cube.D);

  // Snapshot
  const f6 = cube.F[6], f7 = cube.F[7], f8 = cube.F[8];
  const r6 = cube.R[6], r7 = cube.R[7], r8 = cube.R[8];
  const b6 = cube.B[6], b7 = cube.B[7], b8 = cube.B[8];
  const l6 = cube.L[6], l7 = cube.L[7], l8 = cube.L[8];

  // Cycle: F → R → B → L → F
  cube.R[6] = f6; cube.R[7] = f7; cube.R[8] = f8;
  cube.B[6] = r6; cube.B[7] = r7; cube.B[8] = r8;
  cube.L[6] = b6; cube.L[7] = b7; cube.L[8] = b8;
  cube.F[6] = l6; cube.F[7] = l7; cube.F[8] = l8;
}

function R() {
  rotateFaceCW(cube.R);

  // Snapshot
  const u2 = cube.U[2], u5 = cube.U[5], u8 = cube.U[8];
  const f2 = cube.F[2], f5 = cube.F[5], f8 = cube.F[8];
  const d2 = cube.D[2], d5 = cube.D[5], d8 = cube.D[8];
  const b6 = cube.B[6], b3 = cube.B[3], b0 = cube.B[0];

  // Correct R cycle: U → B → D → F → U
  cube.B[6] = u2; cube.B[3] = u5; cube.B[0] = u8;
  cube.D[2] = b6; cube.D[5] = b3; cube.D[8] = b0;
  cube.F[2] = d2; cube.F[5] = d5; cube.F[8] = d8;
  cube.U[2] = f2; cube.U[5] = f5; cube.U[8] = f8;
}

function L() {
  rotateFaceCW(cube.L);

  const u0 = cube.U[0], u3 = cube.U[3], u6 = cube.U[6];
  const f0 = cube.F[0], f3 = cube.F[3], f6 = cube.F[6];
  const d0 = cube.D[0], d3 = cube.D[3], d6 = cube.D[6];
  const b8 = cube.B[8], b5 = cube.B[5], b2 = cube.B[2];

  cube.F[0] = u0; cube.F[3] = u3; cube.F[6] = u6;
  cube.D[0] = f0; cube.D[3] = f3; cube.D[6] = f6;
  cube.B[8] = d0; cube.B[5] = d3; cube.B[2] = d6;
  cube.U[0] = b8; cube.U[3] = b5; cube.U[6] = b2;
}

function F() {
  rotateFaceCW(cube.F);

  const u6 = cube.U[6], u7 = cube.U[7], u8 = cube.U[8];
  const r0 = cube.R[0], r3 = cube.R[3], r6 = cube.R[6];
  const d2 = cube.D[2], d1 = cube.D[1], d0 = cube.D[0];
  const l8 = cube.L[8], l5 = cube.L[5], l2 = cube.L[2];

  cube.R[0] = u6; cube.R[3] = u7; cube.R[6] = u8;
  cube.D[2] = r0; cube.D[1] = r3; cube.D[0] = r6;
  cube.L[8] = d2; cube.L[5] = d1; cube.L[2] = d0;
  cube.U[6] = l8; cube.U[7] = l5; cube.U[8] = l2;
}

function B() {
  rotateFaceCW(cube.B);

  const U = [cube.U[0], cube.U[1], cube.U[2]];
  const R = [cube.R[2], cube.R[5], cube.R[8]];
  const D = [cube.D[6], cube.D[7], cube.D[8]];
  const L = [cube.L[0], cube.L[3], cube.L[6]];

  // U -> L (reversed)
  cube.L[0] = U[2];
  cube.L[3] = U[1];
  cube.L[6] = U[0];

  // L -> D (reversed)
  cube.D[6] = L[2];
  cube.D[7] = L[1];
  cube.D[8] = L[0];

  // D -> R (reversed)
  cube.R[2] = D[2];
  cube.R[5] = D[1];
  cube.R[8] = D[0];

  // R -> U (reversed)
  cube.U[0] = R[2];
  cube.U[1] = R[1];
  cube.U[2] = R[0];
}

function resetCube() {
  cube.U.fill('W');
  cube.R.fill('R');
  cube.F.fill('G');
  cube.D.fill('Y');
  cube.L.fill('O');
  cube.B.fill('B');
}

generateWcaScramble();
// Update the content of the div with id "scramble" with the generated scramble
document.getElementById('scramble').textContent = scramble;
printScrambleMoves();
</script>

</body>
</html>